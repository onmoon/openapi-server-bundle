<?php

declare(strict_types=1);

namespace OnMoon\OpenApiServerBundle\CodeGenerator\PhpParserGenerators;

use Exception;
use OnMoon\OpenApiServerBundle\CodeGenerator\Definitions\DtoDefinition;
use OnMoon\OpenApiServerBundle\CodeGenerator\Definitions\GeneratedFileDefinition;
use OnMoon\OpenApiServerBundle\CodeGenerator\Definitions\PropertyDefinition;
use OnMoon\OpenApiServerBundle\CodeGenerator\Definitions\ResponseDtoDefinition;
use OnMoon\OpenApiServerBundle\Exception\CannotGenerateCodeForOperation;
use OnMoon\OpenApiServerBundle\Types\ScalarTypesResolver;
use PhpParser\Builder;
use PhpParser\Builder\Method;
use PhpParser\Builder\Param;
use PhpParser\Builder\Property;
use PhpParser\Node\Arg;
use PhpParser\Node\Expr;
use PhpParser\Node\Expr\Array_;
use PhpParser\Node\Expr\ArrayItem;
use PhpParser\Node\Expr\ArrowFunction;
use PhpParser\Node\Expr\Assign;
use PhpParser\Node\Expr\AssignOp\Coalesce as CoalesceAssign;
use PhpParser\Node\Expr\BinaryOp\Identical;
use PhpParser\Node\Expr\FuncCall;
use PhpParser\Node\Expr\MethodCall;
use PhpParser\Node\Expr\StaticCall;
use PhpParser\Node\Expr\Ternary;
use PhpParser\Node\Expr\Variable;
use PhpParser\Node\Name;
use PhpParser\Node\Param as Param_;
use PhpParser\Node\Scalar\String_;
use PhpParser\Node\Stmt;
use PhpParser\Node\Stmt\Expression;
use PhpParser\Node\Stmt\If_;
use PhpParser\Node\Stmt\Return_;
use function array_map;
use function count;
use function Safe\sprintf;

class DtoCodeGenerator extends CodeGenerator
{
    public function generate(DtoDefinition $definition) : GeneratedFileDefinition
    {
        $fileBuilder = $this
            ->factory
            ->namespace($definition->getNamespace());

        $classBuilder = $this
            ->factory
            ->class($definition->getClassName())
            ->makeFinal()
            ->setDocComment(sprintf(self::AUTOGENERATED_WARNING, 'class'));

        $implements = $definition->getImplements();
        if ($implements !== null) {
            $classBuilder->implement($implements->getClassName());
            $this->use($fileBuilder, $definition->getNamespace(), $implements);
        }

        foreach ($definition->getProperties() as $property) {
            $object = $property->getObjectTypeDefinition();
            if ($object === null) {
                continue;
            }

            $this->use($fileBuilder, $definition->getNamespace(), $object);
        }

        $classBuilder->addStmts($this->generateProperties($definition));
        $classBuilder->addStmts($this->generateConstructor($definition));
        $classBuilder->addStmts($this->generateGetters($definition));
        $classBuilder->addStmts($this->generateSetters($definition));

        if ($definition instanceof ResponseDtoDefinition) {
            $classBuilder->addStmt($this->generateResponseCodeStaticMethod($definition));
        }

        $needSerializerClass = false;
        $classBuilder->addStmt($this->generateToArray($definition, $needSerializerClass));
        $classBuilder->addStmt($this->generateFromArray($definition, $needSerializerClass));
        if ($needSerializerClass) {
            $fileBuilder->addStmt($this->factory->use(ScalarTypesResolver::SERIALIZER_FULL_CLASS));
        }

        $fileBuilder = $fileBuilder->addStmt($classBuilder);

        return new GeneratedFileDefinition(
            $definition,
            $this->printFile($fileBuilder)
        );
    }

    /**
     * @return Builder[]
     */
    private function generateProperties(DtoDefinition $definition) : array
    {
        $properties = [];
        foreach ($definition->getProperties() as $property) {
            $properties[] = $this->generateClassProperty($property);
        }

        return $properties;
    }

    /**
     * @return Builder[]
     */
    private function generateGetters(DtoDefinition $definition) : array
    {
        $properties = [];
        foreach ($definition->getProperties() as $property) {
            if (! $property->hasGetter()) {
                continue;
            }

            $properties[] = $this->generateGetter($property);
        }

        return $properties;
    }

    /**
     * @return Builder[]
     */
    private function generateSetters(DtoDefinition $definition) : array
    {
        $properties = [];
        foreach ($definition->getProperties() as $property) {
            if (! $property->hasSetter()) {
                continue;
            }

            $properties[] = $this->generateSetter($property);
        }

        return $properties;
    }

    /**
     * @return Builder[]
     */
    private function generateConstructor(DtoDefinition $definition) : array
    {
        $constructorBuilder = $this->factory->method('__construct')->makePublic();
        $constructorDocs    = [];
        $constructorEmpty   = true;

        foreach ($definition->getProperties() as $property) {
            if (! $property->isInConstructor()) {
                continue;
            }

            $constructorEmpty = false;
            $constructorBuilder
                ->addParam($this->generateMethodParameter($property))
                ->addStmt($this->getAssignmentDefinition($property->getClassPropertyName()));
            if (! $this->fullDocs && ! $property->isArray()) {
                continue;
            }

            $constructorDocs[] = sprintf(
                '@param %s $%s',
                $this->getTypeDocBlock($property),
                $property->getClassPropertyName()
            );
        }

        if ($constructorEmpty) {
            return [];
        }

        if (count($constructorDocs) > 0) {
            $constructorBuilder->setDocComment($this->getDocComment($constructorDocs));
        }

        return [$constructorBuilder];
    }

    private function generateClassProperty(PropertyDefinition $definition) : Property
    {
        $property = $this->factory
            ->property($definition->getClassPropertyName())
            ->makePrivate();

        if ($definition->getDefaultValue() !== null) {
            $property->setDefault($definition->getDefaultValue());
        } elseif ($definition->isNullable()) {
            $property->setDefault(null);
        }

        $property->setType($this->getTypePhp($definition));

        $docCommentLines = [];

        if ($definition->getDescription() !== null) {
            $docCommentLines[] = sprintf('%s', $definition->getDescription());
            $docCommentLines[] = '';
        }

        $supportSymfonySerializer = true;
        /*
         * Symfony serializer does not support property class definitions.
         * ToDo: Remove this hack and phpstan ignores after serializer is no longer used.
         */

        /** @phpstan-ignore-next-line */
        if ($this->fullDocs || $definition->isArray() || $supportSymfonySerializer) {
            $docCommentLines[] = sprintf(
                '@var %s $%s ',
                $this->getTypeDocBlock($definition),
                $definition->getClassPropertyName()
            );
        }

        /** @phpstan-ignore-next-line */
        if (count($docCommentLines)) {
            $property->setDocComment($this->getDocComment($docCommentLines));
        }

        return $property;
    }

    private function generateMethodParameter(PropertyDefinition $definition) : Param
    {
        return $this
            ->factory
            ->param($definition->getClassPropertyName())
            ->setType($this->getTypePhp($definition));
    }

    private function getAssignmentDefinition(string $name) : Assign
    {
        return new Assign(
            new Variable('this->' . $name),
            new Variable($name)
        );
    }

    private function generateGetter(PropertyDefinition $definition) : Method
    {
        $getterName = $definition->getGetterName();
        if ($getterName === null) {
            throw new Exception('Getter name should be set it hasGetter is true');
        }

        $method = $this->factory
            ->method($getterName)
            ->makePublic()
            ->setReturnType($this->getTypePhp($definition))
            ->addStmt(new Return_(new Variable('this->' . $definition->getClassPropertyName())));

        if ($this->fullDocs || $definition->isArray()) {
            $method->setDocComment(
                $this->getDocComment(['@return ' . $this->getTypeDocBlock($definition)])
            );
        }

        return $method;
    }

    private function generateSetter(PropertyDefinition $definition) : Method
    {
        $setterName = $definition->getSetterName();
        if ($setterName === null) {
            throw new Exception('Setter name should be set it hasSetter is true');
        }

        $method = $this->factory
            ->method($setterName)
            ->makePublic()
            ->setReturnType('self')
            ->addParam($this->generateMethodParameter($definition))
            ->addStmt($this->getAssignmentDefinition($definition->getClassPropertyName()))
            ->addStmt(new Return_(new Variable('this')));

        if ($this->fullDocs || $definition->isArray()) {
            $blocks = [
                sprintf(
                    '@param %s $%s',
                    $this->getTypeDocBlock($definition),
                    $definition->getClassPropertyName()
                ),
            ];
            if ($this->fullDocs) {
                $blocks[] = '@return self';
            }

            $method->setDocComment($this->getDocComment($blocks));
        }

        return $method;
    }

    private function generateResponseCodeStaticMethod(ResponseDtoDefinition $definition) : Method
    {
        $responseCode = (int) $definition->getStatusCode();
        $method       = $this
            ->factory
            ->method('_getResponseCode')
            ->makePublic()
            ->makeStatic()
            ->setReturnType('?int')
            ->addStmt(
                new Return_(
                    $this->factory->val($responseCode !== 0 ? $responseCode : null)
                )
            );
        if ($this->fullDocs) {
            $method->setDocComment(
                $this->getDocComment(['@return ?int'])
            );
        }

        return $method;
    }

    private function generateToArray(DtoDefinition $definition, bool &$needSerializerClass) : Method
    {
        return $this
            ->factory
            ->method('toArray')
            ->makePublic()
            ->setReturnType('array')
            ->setDocComment($this->getDocComment(['@inheritDoc']))
            ->addStmt(
                new Return_(
                    new Array_(
                        array_map(
                            function ($p) use (&$needSerializerClass) {
                                /** @psalm-suppress MixedArgument */
                                return $this->generateToArrayItem($p, $needSerializerClass);
                            },
                            $definition->getProperties()
                        )
                    )
                )
            );
    }

    private function generateToArrayItem(PropertyDefinition $property, bool &$needSerializerClass) : ArrayItem
    {
        $source = new Variable('this->' . $property->getClassPropertyName());

        $serializer = null;
        $scalarType = $property->getScalarTypeId();
        if ($scalarType !== null) {
            $serializerFn = $this->typeResolver->getSerializer($scalarType);
            if ($serializerFn !== null) {
                $serializer          = static fn (Expr $v) : Expr => new StaticCall(
                    new Name(ScalarTypesResolver::SERIALIZER_CLASS),
                    $serializerFn,
                    [new Arg($v)]
                );
                $needSerializerClass = true;
            }
        } elseif ($property->getObjectTypeDefinition() !== null) {
            $serializer = static fn (Expr $v) : Expr => new MethodCall($v, 'toArray');
        }

        if ($property->isArray() && $serializer !== null) {
            $serializer = fn (Expr $v) : Expr => new FuncCall(
                new Name('array_map'),
                [
                    new Arg(
                        new ArrowFunction(
                            [
                                'static' => true,
                                'params' => [$this->factory->param('v')->getNode()],
                                'expr' => $serializer(new Variable('v')),
                            ]
                        )
                    ),
                    new Arg($v),
                ]
            );
        }

        if ($property->isNullable() && $serializer !== null) {
            $serializer = fn (Expr $v) : Expr => new Ternary(
                new Identical($this->factory->val(null), $v),
                $this->factory->val(null),
                $serializer($v)
            );
        }

        return new ArrayItem(
            $serializer !== null ? $serializer($source) : $source,
            new String_($property->getSpecPropertyName())
        );
    }

    private function generateFromArray(DtoDefinition $definition, bool &$needSerializerClass) : Method
    {
        $source = new Variable('data');

        $args       = [];
        $setters    = [];
        $statements = [];

        foreach ($definition->getProperties() as $property) {
            $fetch  = $this->generateFromArrayPropFetch($property, $source, $needSerializerClass);

            if ($property->isInConstructor()) {
                if (!$property->isRequired()) {
                    $statements[] = new CoalesceAssign(
                        $this->generateFromArrayGetValue($property, $source),
                        $this->factory->val(null)
                    );
                }

                $args[] = $fetch;
            } elseif ($property->hasSetter()) {
                $setterName = $property->getSetterName();
                if ($setterName === null) {
                    throw new Exception('setterName can not be null if hasSetter is true');
                }

                $setter = static fn (Expr $v) : Stmt =>  new Expression(new MethodCall($v, $setterName, [$fetch]));
                if (! $property->isRequired()) {
                    $setter = fn (Expr $v) : Stmt => new If_(
                        $this->factory->funcCall('array_key_exists', [$property->getSpecPropertyName(), $source]),
                        [
                            'stmts' => [$setter($v)],
                        ]
                    );
                }

                $setters[] = $setter;
            } else {
                throw CannotGenerateCodeForOperation::becauseNoAssignmentFound(
                    $definition->getClassName(),
                    $property->getSpecPropertyName()
                );
            }
        }

        $new = new Expr\New_(new Name($definition->getClassName()), $args);

        if(count($setters) > 0) {
            $var = new Variable('dto');
            $statements[] = new Assign($var, $new);
            foreach ($setters as $setter) {
                $statements[] = $setter($var);
            }
            $statements[] = new Return_($var);
        } else {
            $statements[] = new Return_($new);
        }

        return $this
            ->factory
            ->method('fromArray')
            ->makePublic()
            ->makeStatic()
            ->setReturnType('self')
            ->addParam(new Param_($source, null, 'array'))
            ->setDocComment($this->getDocComment(['@inheritDoc']))
            ->addStmts($statements);
    }

    private function generateFromArrayPropFetch(PropertyDefinition $property, Variable $sourceVar, bool &$needSerializerClass) : Arg
    {
        $source = $this->generateFromArrayGetValue($property, $sourceVar);

        $deserializer = null;
        $scalarType = $property->getScalarTypeId();
        $objectType = $property->getObjectTypeDefinition();
        if ($scalarType !== null) {
            $deserializerFn = $this->typeResolver->getDeserializer($scalarType);
            if ($deserializerFn !== null) {
                $deserializer          = static fn (Expr $v) : Expr => new StaticCall(
                    new Name(ScalarTypesResolver::SERIALIZER_CLASS),
                    $deserializerFn,
                    [new Arg($v)]
                );
                $needSerializerClass = true;
            }
        } elseif ($objectType !== null) {
            $deserializer = static fn (Expr $v) : Expr => new StaticCall(new Name($objectType->getClassName()), 'fromArray', [new Arg($v)]);
        }

        if ($property->isArray() && $deserializer !== null) {
            $deserializer = fn (Expr $v) : Expr => new FuncCall(
                new Name('array_map'),
                [
                    new Arg(
                        new ArrowFunction(
                            [
                                'static' => true,
                                'params' => [$this->factory->param('v')->getNode()],
                                'expr' => $deserializer(new Variable('v')),
                            ]
                        )
                    ),
                    new Arg($v),
                ]
            );
        }

        if ($property->isNullable() && $deserializer !== null) {
            $deserializer = fn (Expr $v) : Expr => new Ternary(
                new Identical($this->factory->val(null), $v),
                $this->factory->val(null),
                $deserializer($v)
            );
        }


        return new Arg($deserializer === null ? $source : $deserializer($source));
    }

    private function generateFromArrayGetValue(PropertyDefinition $property, Variable $sourceVar) : Expr {
        return new Expr\ArrayDimFetch($sourceVar, new String_($property->getSpecPropertyName()));
    }
}
